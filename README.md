# Manage Bookings ğŸ—“ï¸

A modern, scalable **React application** built with **Vite** and **Redux Toolkit**, designed to manage bookings efficiently with a clean UI, predictable state management, and high performance.

This project goes beyond the default Vite + React template and is structured like a real-world, production-ready frontend application.

---

## ğŸš€ Tech Stack

### Core
- **React 19** â€“ Component-based UI library
- **Vite (Rolldown)** â€“ Ultra-fast dev server and optimized builds
- **React Router v7** â€“ Client-side routing

### State Management
- **Redux Toolkit** â€“ Simplified and scalable Redux setup
- **React Redux** â€“ Official Redux bindings for React
- **Redux Logger** â€“ Middleware for debugging Redux state changes (dev-friendly)

### UI & UX
- **Ant Design (antd)** â€“ Enterprise-grade UI component library
- **@react-google-maps/api** â€“ Google Maps integration for location-based features

### Tooling & Code Quality
- **ESLint** â€“ Enforces consistent coding standards
- **Fast Refresh (HMR)** â€“ Instant UI updates during development

---

## ğŸ“¦ Dependencies Overview

The project uses the following key libraries:

- `react`, `react-dom`
- `react-router-dom`
- `@reduxjs/toolkit`, `react-redux`
- `redux-logger`
- `antd`
- `@react-google-maps/api`
- `vite` (via `rolldown-vite`)
- `eslint` and related plugins

---

I want all this perfectly formatted inside of an editor

### Architectural Notes
- Feature-first folder structure
- Clear separation of concerns
- Designed for scalability
- Easy onboarding for new developers

---

## ğŸ› ï¸ Getting Started

### Prerequisites
- Node.js 18+ (recommended)
- npm


## âš¡ Vite + Rolldown Setup
This project uses Rolldown-powered Vite for improved performance and future-ready bundling.

### Benefits
- Faster builds
- Efficient dependency handling
- Babel-based Fast Refresh via @vitejs/plugin-react

## ğŸ§  State Management Philosophy
- Redux Toolkit is used for predictable, centralized state
- Business logic lives inside Redux slices
- UI components remain lean and reusable
- Middleware such as redux-logger improves debugging during development

## ğŸ”’ Code Quality & Best Practices
- ESLint with React Hooks rules enabled
- Consistent coding style across the project
- Clear separation between UI, state, routing, and services
- Designed for long-term maintainability

## ğŸ“ˆ Scalability & Future Enhancements
The architecture supports easy extension for:
- TypeScript migration
- API caching (RTK Query / React Query)
- Authentication and role-based access control
- Automated testing (Jest / Playwright)
- Performance optimizations and code splitting

## ğŸ‘¨â€ğŸ’» Author
**Front-end team**  
Engineer first. Focused on clean architecture, scalable systems, and high-quality frontend engineering.
